// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "lamportservice.h"
// Protocol includes
#include <thrift/protocol/TBinaryProtocol.h>
// Server includes
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/server/TThreadedServer.h>
// Transport includes
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>
// Concurrency includes
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PlatformThreadFactory.h>
// Other includes
#include <vector>
#include <mutex> 

// Namespaces
using namespace ::apache::thrift;
using namespace apache::thrift::concurrency;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

// Server 2
boost::shared_ptr<TSocket> socket2(new TSocket("127.0.0.1", 9091));
boost::shared_ptr<TTransport> transport2(new TFramedTransport(socket2));
boost::shared_ptr<TProtocol> protocol2(new TBinaryProtocol(transport2));

lamportserviceClient server2(protocol2);

// Server 3
boost::shared_ptr<TSocket> socket3(new TSocket("127.0.0.1", 9092));
boost::shared_ptr<TTransport> transport3(new TFramedTransport(socket3));
boost::shared_ptr<TProtocol> protocol3(new TBinaryProtocol(transport3));

lamportserviceClient server3(protocol3);

// Globale Variablen
int nodeID;
int servertime = 1;
std::vector<TimeStamp> requestQueue;
std::mutex mtx;

class lamportserviceHandler : virtual public lamportserviceIf {
 public:
  lamportserviceHandler() {
	// Set unique node ID
	std::cout << "Enter unique node ID: ";
	std::cin >> nodeID;
	std::cout << "Server #1 ready" << std::endl;
  }

  bool request(const TimeStamp& timestamp) {
	std::cout << "Request" << std::endl;
	// Add this timestamp to que
	requestQueue.push_back(timestamp);

	// REQUEST: Increment time
	if(timestamp.time >= servertime) {
		servertime = timestamp.time + 1;
	} else {
		servertime += timestamp.time + 1;
	}
	

	// Output timestamp
	std::cout << "(" << servertime << ", " << nodeID << ") Request" << std::endl;
	std::cout << "Queue after Request: ";
	// Output request queue
	for(int i=0; i<requestQueue.size(); i++) {
		std::cout << "(" << requestQueue.at(i).time << ", " << requestQueue.at(i).id << "), ";
	}
	std::cout << std::endl;
		
	// Share request with server 2 and server 3
	transport2->open();
	server2.sharedrequest(timestamp);
	transport2->close();
	transport3->open();
	server3.sharedrequest(timestamp);
	transport3->close();

	// Acknowledge the request
	return true;
  }

  void sharedrequest(const TimeStamp& timestamp) {
	// Add this timestamp to que
	requestQueue.push_back(timestamp);

	// REQUEST: Increment time
	if(timestamp.time >= servertime) {
		servertime = timestamp.time + 1;
	} else {
		servertime += timestamp.time + 1;
	}

	// Output timestamp
	std::cout << "(" << servertime << ", " << nodeID << ") Shared Request" << std::endl;
	std::cout << "Queue after Request: ";
	// Output request queue
	for(int i=0; i<requestQueue.size(); i++) {
		std::cout << "(" << requestQueue.at(i).time << ", " << requestQueue.at(i).id << "), ";
	}

	std::cout << std::endl;
  }

  void release(const TimeStamp& timestamp) {
	// Find and remove Node from queue
	for(int i=0; i<requestQueue.size(); i++) {
		if(requestQueue.at(i).time == timestamp.time && requestQueue.at(i).id == timestamp.id) {
			requestQueue.erase(requestQueue.begin()+i);
			break;
		}
	}

	// Share release with server 2 and server 3
	transport2->open();
	server2.sharedrelease(timestamp);
	transport2->close();
	transport3->open();
	server3.sharedrelease(timestamp);
	transport3->close();

	// RELEASE: Increment time
	if(timestamp.time >= servertime) {
		servertime = timestamp.time + 1;
	} else {
		servertime += timestamp.time + 1;
	}

	// Output timestamp
	std::cout << "(" << servertime << ", " << nodeID << ") Release" << std::endl;	
	std::cout << "Queue after Release: ";
	// Output request queue
	for(int i=0; i<requestQueue.size(); i++) {
		std::cout << "(" << requestQueue.at(i).time << ", " << requestQueue.at(i).id << "), ";
	}
	std::cout << std::endl;
  }

  void sharedrelease(const TimeStamp& timestamp) {
	// Find and remove Node from queue
	for(int i=0; i<requestQueue.size(); i++) {
		if(requestQueue.at(i).time == timestamp.time && requestQueue.at(i).id == timestamp.id) {
			requestQueue.erase(requestQueue.begin()+i);
			break;
		}
	}
	// RELEASE: Increment time
	if(timestamp.time >= servertime) {
		servertime = timestamp.time + 1;
	} else {
		servertime += timestamp.time + 1;
	}
	// Output timestamp
	std::cout << "(" << servertime << ", " << nodeID << ") Shared Release" << std::endl;	
	std::cout << "Queue after Release: ";
	// Output request queue
	for(int i=0; i<requestQueue.size(); i++) {
		std::cout << "(" << requestQueue.at(i).time << ", " << requestQueue.at(i).id << "), ";
	}
	std::cout << std::endl;
  }

  void lock() {
	// Lock the requested resource
	std::cout << "Locking ressource..." << std::endl;
	mtx.lock();
  }

  void unlock() {
	// Unlock the requested resource
	std::cout << "Unlocking ressource..." << std::endl;
	mtx.unlock();
  }


  void getQueue(std::vector<TimeStamp> & _return) {
	// Return the request Queue
    	_return = requestQueue;
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  int numThreads = 10;
  shared_ptr<lamportserviceHandler> handler(new lamportserviceHandler());
  shared_ptr<TProcessor> processor(new lamportserviceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(numThreads);
  shared_ptr<ThreadFactory> threadFactory(new PosixThreadFactory()); 

  threadManager->threadFactory(threadFactory);
  threadManager->start(); 

  TServer* server = NULL;
  server =  new TNonblockingServer(processor, protocolFactory, port, threadManager);

  server->serve();
  return 0;
}

